#!/bin/sh

log ()
{
	echo $1
	logger -s -t "Emerald Base" -p local4.notice "$1"
}

# See if we find a new calibration file for non-pointercal data
NEWCAL=/flags/set-ts.sh
if [ -x $NEWCAL -a -s $NEWCAL ]; then
	log "setcal: Reading TS sensitivity calibration data from $NEWCAL"
else
	log "setcal: Missing TS sensitivity calibration data file: $NEWCAL"
	log "setcal: Creating new one from 'tsp' region in NOR..."
	mfgdata get tsp > $NEWCAL
	chmod +x $NEWCAL
fi

# Run it
$NEWCAL
if [ $? == 0 ]; then
	log "setcal: $NEWCAL success"
else
	if grep "ILI6480G2" /proc/cmdline > /dev/null; then
		log "setcal: $NEWCAL generated from missing or corrupted NOR 'tsp' data; using defaults for 5inch"
		SYS=/sys/devices/platform/lf1000-touchscreen
		echo 50 > $SYS/max_tnt_down
		echo 500 > $SYS/min_tnt_up
		echo 20 > $SYS/max_delta_tnt
		echo 30 > $SYS/delay_in_us
		echo 15 > $SYS/y_delay_in_us
		echo 40 > $SYS/tnt_delay_in_us
		echo "384 777 806 821 848 1061 1102 1133 1186" > $SYS/pressure_curve
		# ILI9322
		# NT39016
		# HX8238
	else
		log "setcal: $NEWCAL generated from missing or corrupted NOR 'tsp' data; using defaults for 3inch"
	fi
	# log "setcal: ###### To remove this message, please calibrate with ######"
	# log "setcal: ###### new-calib, then run this line to update NOR:  ######"
	# log "setcal: ###### mfgdata set tspr `cat /tmp/mfgdata-tspr-data` ######"
fi

# Load the touchscreen calibration matrix into the touchscreen driver
USERCAL=/flags/pointercal
MFGDATA=/usr/bin/mfgdata
DEFAULT=/sys/devices/platform/lf1000-touchscreen/pointercal
SETCAL=/sys/devices/platform/lf1000-touchscreen

# Add ability to force calibration by holding hint during boot
. /usr/bin/recovery-functions
if button_down $BUTTON_HINT || button_down $BUTTON_ESC; then
	touch /tmp/force_cal # force calibration
	touch /tmp/splash # skip movie too
fi

validate ()
{
	# Test for exactly 7 values
	if [ `echo "$*" | wc -w` != 7 ]; then
		log "setcal:validate fails 7 arg count: '$*'"
		return 1 # Fail
	fi
	# Test for all 0's from uninit'd NOR contents
	if [ "$*" = "0 0 0 0 0 0 0" ]; then
		log "setcal:validate fails all 0 test: '$*'"
		return 1 # Fail
	fi
	# Test for non-numbers
	if echo "$*" | awk '{ exit $1==0+$1 && $2==0+$2 && $3==0+$3 && $4==0+$4 && $5==0+$5 && $6==0+$6 && $7==0+$7 }'; then
		# fail = exit 0 in this case, so inverted sense of test
		log "setcal:validate fails non-numeric test: '$*'"
		return 1 # Fail
	fi
	# Test for 7th value being 65536 or else!
	if [ "$7" != "65536" ]; then
		log "setcal:validate fails 7th=65536 test: '$*'"
		return 1 # Fail
	fi
	return 0 # Pass
}

# Give to driver
accept ()
{
	# echo $3 > $SETCAL/a0
	# echo $1 > $SETCAL/a1
	# echo $2 > $SETCAL/a2
	# echo $6 > $SETCAL/a3
	# echo $4 > $SETCAL/a4
	# echo $5 > $SETCAL/a5
	# echo $7 > $SETCAL/a6
	echo $* > $DEFAULT
}

# Atomic Save in NAND for faster access next time
save ()
{
	echo $* > $USERCAL.new
	chmod 666 $USERCAL.new	# Let non-root users overwrite this
	# Actually, it is the mode of /flags that matters; the next writer
	# is an atomic write (i.e, mv).  And /flags is 777, so anyone can mv.
	sync # I want fsync here, but I don't know how to get it.
	mv $USERCAL.new $USERCAL
}

# Pick the best pointercal data we can find...
# First USERCAL, then MFGDATA, then DEFAULT
cal=`cat $USERCAL || echo ""`
if validate $cal; then
	log "setcal: Using USERCAL in $USERCAL $cal"
	accept $cal
	exit 0
fi
# Try to get data from NOR
cal=`$MFGDATA get ts || echo ""`
if validate $cal; then
	log "setcal: No USERCAL in $USERCAL; creating one with MfgData! $cal"
	accept $cal
	save $cal
	exit 0;
fi
# This last one has to work!
cal=`cat $DEFAULT || echo ""`
if validate $cal; then
	log "setcal: No USERCAL $USERCAL or MfgData: falling back on DEFAULT!! $cal"
	accept $cal
	# Don't save it and Signal to UI that cal is desirable
	# save $cal
	touch /tmp/force_cal
	exit 0;
else
	log "setcal: All touchscreen calibration missing!!!  Unable to even find driver default!!!" 
	touch /tmp/force_cal
	exit 1
fi
exit 0
