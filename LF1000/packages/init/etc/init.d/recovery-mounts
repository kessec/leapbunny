#!/bin/sh

# Try to mount patient's file system

# Supported?
SYS=/sys/devices/platform/lf1000-nand/new_mtd
if [ ! -e $SYS ]; then
	echo "Give up; kernel does not support new mtd parts at run time"
	exit 1
fi

# Madrid/ext?
EXT=0
if [ -e /sys/block/mmcblk0 ]; then
	EXT=1
fi

# Two mounts points and flags to indicate doneness
mp_root=/patient-rfs
mp_bulk=/patient-bulk
tp0=/tmp/ready_
fs=/var/1.2.0.fs

operation="$1"
shift

# Allow remaining args to override mount points, or anything for that matter
# So... to override the bulk mount point, try setting the mp_bulk variable:
#     /etc/init.d/recovery-mounts (start|startro|stop) mp_bulk=/LF/Bulk
# You can also set mp_root to override the rfs mount point.
# Note: you must use the same mount point(s) on stop as you did on start
for a in $*; do
	eval $a
done

get_ud ()
{
	# Without a loop, walk sys/class/ubi looking for ubi_bulk and set ud to the ubi#
	ud=`find /sys/class/ubi -name name | \
		xargs awk "/$1/ { x=split(FILENAME,y,\"/\"); print y[x-2] }" | \
		sed -e 's/ubi//'`
}

case "$operation" in
	start|startro)
		# Three steps: 
		# 1) Create alias devices in mtd map fraction of whole nand into new mtd device
		# 2) ubi attach
		# 3) mount

		echo "operation=$operation mp_root=$mp_root mp_bulk=$mp_bulk"
		# Make mount points 1) patient 2) patient/LF/Bulk
		mkdir -p $mp_root $mp_bulk
		rwmode=rw
		if [ $operation == startro ]; then
			rwmode=ro
		fi

		# For Madrid, do mounts the "easy" way.  [Not so easy now!]
		if [ $EXT = 1 ]; then
			# Process each mount point we're interested in
			while read dev where name; do
				# Early out if already mounted
				if grep $dev /proc/mounts > /dev/null; then
					echo "$dev already mounted"
					continue;
				fi
				mount -o $rwmode $dev $where
				if [ $? != 0 ]; then
					echo "failed to mount $dev $where."
				else
					echo "success mounting $uv"
				fi
				# We're done: leave a flag 
				touch ${tp0}$name
			done <<EOF
/dev/mmcblk0p3 $mp_root rfs
/dev/mmcblk0p4 $mp_bulk bulk
EOF
			exit 0; # Early out for Madrid
		fi

		# Process each mount point we're interested in
		# Get data from "here doc" about 50 lines down from, uh, here.
		while read match name uv where; do
			# Find match in $fs
			#### was: fgrep $match $fs | while read offset size bilge.
			# Do hack because pipe to 'read' only updates locals!
			hack=`mktemp /tmp/hack.XXXXXX`
			fgrep $match $fs > $hack
			read offset size bilge < $hack
			rm $hack

			# Early out if already mounted
			if grep $uv /proc/mounts > /dev/null; then
				echo "$uv already mounted"
				continue;
			fi
			# Create alias, if needed
			pname="Pat_$name"
			if fgrep $pname /proc/mtd > /dev/null; then
				echo "Alias for $pname already present"
			else
				echo "Create alias: $offset $size $name $where"
				lcname=`echo $name | tr A-Z a-z`
				echo "0 $offset $size $pname" > $SYS
				if fgrep $pname /proc/mtd > /dev/null; then
					echo "Alias created ok"
				else
					echo "Failed to create '$offset $size $name $where'!  Why???"
					exit 1
				fi
			fi
			# ubi attach if needed
			get_ud "$uv"
			if [ -z "$ud" ]; then
				mn=`fgrep $pname /proc/mtd | head -1 | cut -d : -f 1 | cut -c 4-`
				echo "mn=$mn"
				ubiattach /dev/ubi_ctrl -m $mn
				res=$?
				if [ $res != 0 ]; then
					echo "Attach of $mn failed: exit=$res"
					continue;
				else
					echo "Attach of $mn succeeded"
				fi
				get_ud "$uv"
				if [ -z "$ud" ]; then
					echo "Failed to find $uv in /sys!  Impossible!!!"
					continue;
				fi
			else
				echo "Attach for $uv already present"
			fi
			# Mount
			mount -t ubifs -o $rwmode ubi${ud}:${uv} $where
			if [ $? != 0 ]; then
				echo "failed to mount ubi${ud}:${uv} $where.  Cleaning up..."
				# detach as a clean up to leave things ready for next time
				ubidetach /dev/ubi_ctrl -d $ud
				res=$?
				if [ $res != 0 ]; then
					echo "failed to ubidetach $ud: exit=$res"
				else
					echo "success: ubidetach $ud"
				fi
				# Remove alias --
				# FIXME; not implemented in kernel
				# So we will pile up mtd devices if we "restart"
				# but it works.
				echo "failed to mount $ud -m $mn"
			else
				echo "success mounting $uv"
			fi
			# We're done: leave a flag 
			touch ${tp0}$lcname
		done <<EOF
erootfs.ubi RFS ubi_rfs $mp_root
bulk.ubi Bulk ubi_bulk $mp_bulk
EOF
		;;
	stop)
		# For Madrid, do mounts the "easy" way.  [Not so easy now!]
		if [ $EXT = 1 ]; then
			for uv in /dev/mmcblk0p3 /dev/mmcblk0p4; do
				# umount
				if grep $uv /proc/mounts > /dev/null; then
					umount $uv
					res=$?
					if [ $res != 0 ]; then
						echo "failed to umount $uv $where: exit=$res"
					else
						echo "success: umount $where"
					fi
				else
					echo "No mount for $uv found"
				fi
			done
			exit 0; # Early out for Madrid
		fi

		# Undo three steps in reverse order
		# 3) umount
		# 2) ubi detach
		# 1) Remove alias devices in mtd

		while read uv; do
			# umount
			if grep $uv /proc/mounts > /dev/null; then
				where=`awk /$uv/' { print $2; }' /proc/mounts`
				umount $where
				res=$?
				if [ $res != 0 ]; then
					echo "failed to umount $uv $where: exit=$res"
				else
					echo "success: umount $where"
				fi
			else
				echo "No mount for $uv found"
			fi
			# ubi detach, if needed
			get_ud "$uv"
			if [ -n "$ud" ]; then
				ubidetach /dev/ubi_ctrl -d $ud
				res=$?
				if [ $res != 0 ]; then
					echo "failed to ubidetach $ud: exit=$res"
				else
					echo "success: ubidetach $ud"
				fi
			else
				echo "No detach of $uv done because none found"
			fi
			# Remove alias -- FIXME; not implemented in kernel
		done <<EOF
ubi_rfs
ubi_bulk
EOF
		;;
	restart)
		$0 stop
		$0 start
		;;
	*)
		echo "Usage: $0 {start|startro|stop|restart} [var=value] [var=value]..."
		echo "  where optional var=value pairs are use to override the default mount points:"
		echo "    mp_root=/path/to/mount/rfs"
		echo "    mp_bulk=/path/to/mount/bulk"
		echo "Note: The same mount points must be used with stap as were used with start."
		exit 1
		;;
esac

exit 0
